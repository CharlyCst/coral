diff --git a/compiler/rustc_target/src/spec/mod.rs b/compiler/rustc_target/src/spec/mod.rs
index 8909cf33af9..c4af827c5be 100644
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -1245,6 +1245,8 @@ fn $module() {
     ("x86_64-unknown-none", x86_64_unknown_none),
 
     ("mips64-openwrt-linux-musl", mips64_openwrt_linux_musl),
+
+    ("x86_64-coral-unknown-kernel", x86_64_coral_unknown_kernel),
 }
 
 /// Cow-Vec-Str: Cow<'static, [Cow<'static, str>]>
diff --git a/library/std/build.rs b/library/std/build.rs
index 8b1a06ee750..99c252bf115 100644
--- a/library/std/build.rs
+++ b/library/std/build.rs
@@ -31,6 +31,7 @@ fn main() {
         || target.contains("espidf")
         || target.contains("solid")
         || target.contains("nintendo-3ds")
+        || target.contains("coral")
     {
         // These platforms don't have any special requirements.
     } else {
diff --git a/library/std/src/alloc.rs b/library/std/src/alloc.rs
index 61c1ff578b2..e9d0d85e49b 100644
--- a/library/std/src/alloc.rs
+++ b/library/std/src/alloc.rs
@@ -344,7 +344,7 @@ fn default_alloc_error_hook(layout: Layout) {
     }
 }
 
-#[cfg(not(test))]
+#[cfg(not(any(test, target_vendor = "coral")))]
 #[doc(hidden)]
 #[alloc_error_handler]
 #[unstable(feature = "alloc_internals", issue = "none")]
diff --git a/library/std/src/collections/hash/map.rs b/library/std/src/collections/hash/map.rs
index 708edc5de47..b41f69366b8 100644
--- a/library/std/src/collections/hash/map.rs
+++ b/library/std/src/collections/hash/map.rs
@@ -3106,10 +3106,17 @@ impl RandomState {
     /// ```
     #[inline]
     #[allow(deprecated)]
+    #[allow(unreachable_code)]
     // rand
     #[must_use]
     #[stable(feature = "hashmap_build_hasher", since = "1.7.0")]
     pub fn new() -> RandomState {
+        // For now Coral does not try to provide DoS-resistant hashmap, and does
+        // not yet support thread-local variables, so we just return a fixed
+        // value.
+        #[cfg(target_vendor = "coral")]
+        return RandomState { k0: 14, k1: 15 };
+
         // Historically this function did not cache keys from the OS and instead
         // simply always called `rand::thread_rng().gen()` twice. In #31356 it
         // was discovered, however, that because we re-seed the thread-local RNG
diff --git a/library/std/src/panicking.rs b/library/std/src/panicking.rs
index d4976a469cc..f7810053285 100644
--- a/library/std/src/panicking.rs
+++ b/library/std/src/panicking.rs
@@ -518,7 +518,7 @@ pub fn panicking() -> bool {
 }
 
 /// Entry point of panics from the libcore crate (`panic_impl` lang item).
-#[cfg(not(test))]
+#[cfg(not(any(test, target_vendor = "coral")))]
 #[panic_handler]
 pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {
     struct PanicPayload<'a> {
diff --git a/library/std/src/sys/mod.rs b/library/std/src/sys/mod.rs
index c080c176a2a..5fc58e60719 100644
--- a/library/std/src/sys/mod.rs
+++ b/library/std/src/sys/mod.rs
@@ -43,6 +43,9 @@
     } else if #[cfg(target_family = "wasm")] {
         mod wasm;
         pub use self::wasm::*;
+    } else if #[cfg(target_vendor = "coral")] {
+        mod coral;
+        pub use self::coral::*;
     } else if #[cfg(all(target_vendor = "fortanix", target_env = "sgx"))] {
         mod sgx;
         pub use self::sgx::*;
diff --git a/library/std/src/sys/unsupported/thread_local_dtor.rs b/library/std/src/sys/unsupported/thread_local_dtor.rs
index 84660ea5881..ac0f4041216 100644
--- a/library/std/src/sys/unsupported/thread_local_dtor.rs
+++ b/library/std/src/sys/unsupported/thread_local_dtor.rs
@@ -1,5 +1,6 @@
 #![unstable(feature = "thread_local_internals", issue = "none")]
 
+#[allow(dead_code)]
 #[cfg_attr(target_family = "wasm", allow(unused))] // unused on wasm32-unknown-unknown
 pub unsafe fn register_dtor(_t: *mut u8, _dtor: unsafe extern "C" fn(*mut u8)) {
     // FIXME: right now there is no concept of "thread exit", but this is likely
diff --git a/library/std/src/sys_common/mod.rs b/library/std/src/sys_common/mod.rs
index 8c19f9332dc..760e6c9e810 100644
--- a/library/std/src/sys_common/mod.rs
+++ b/library/std/src/sys_common/mod.rs
@@ -49,6 +49,7 @@
     if #[cfg(any(target_os = "l4re",
                  target_os = "hermit",
                  feature = "restricted-std",
+                 target_vendor = "coral",
                  all(target_family = "wasm", not(target_os = "emscripten")),
                  all(target_vendor = "fortanix", target_env = "sgx")))] {
         pub use crate::sys::net;
diff --git a/src/bootstrap/compile.rs b/src/bootstrap/compile.rs
index e02a10b8164..c9930198938 100644
--- a/src/bootstrap/compile.rs
+++ b/src/bootstrap/compile.rs
@@ -343,6 +343,9 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car
     } else {
         let mut features = builder.std_features(target);
         features.push_str(compiler_builtins_c_feature);
+        if target.contains("coral") {
+            features.push_str(" compiler-builtins-mem");
+        }
 
         cargo
             .arg("--features")
diff --git a/src/bootstrap/lib.rs b/src/bootstrap/lib.rs
index 7e70e99bb8c..a0d29d46cd9 100644
--- a/src/bootstrap/lib.rs
+++ b/src/bootstrap/lib.rs
@@ -210,6 +210,7 @@ pub unsafe fn setup(_build: &mut crate::Build) {}
     /* Extra values not defined in the built-in targets yet, but used in std */
     (Some(Mode::Std), "target_env", Some(&["libnx"])),
     (Some(Mode::Std), "target_os", Some(&["watchos"])),
+    (Some(Mode::Std), "target_vendor", Some(&["coral"])),
     (
         Some(Mode::Std),
         "target_arch",
diff --git a/src/tools/build-manifest/src/main.rs b/src/tools/build-manifest/src/main.rs
index b0006cb90bd..c67c8961cad 100644
--- a/src/tools/build-manifest/src/main.rs
+++ b/src/tools/build-manifest/src/main.rs
@@ -155,6 +155,7 @@
     "x86_64-unknown-none",
     "x86_64-unknown-redox",
     "x86_64-unknown-hermit",
+    "x86_64-unknown-none-coral",
 ];
 
 /// This allows the manifest to contain rust-docs for hosts that don't build
